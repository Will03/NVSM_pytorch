About|the computational technique|the TBN game show|Virtual Memory (game show)
File:Virtual memory.svg|thumb|250px|Virtual memory combines active RAM and inactive memory on Direct access storage device|DASD<ref group=NB>Early systems used Drum memory|drums; contemporary systems use Disk storage|disks or Solid-state drive|solid state memory</ref> to form a large range of contiguous addresses.

In computing, virtual memory (also virtual storage) is a Memory management (operating systems)|memory management technique that provides an "idealized abstraction of the storage resources that are actually available on a given machine"<ref>cite book|last1=Bhattacharjee|first1=Abhishek|last2=Lustig|first2=Daniel|title=Architectural and Operating System Support for Virtual Memory|date=2017|publisher=Morgan & Claypool Publishers|isbn=9781627056021|page=1|url=https://books.google.com/books?id=roM4DwAAQBAJ|accessdate=October 16, 2017</ref> which "creates the illusion to users of a very large (main) memory."<ref>cite book|last1=Haldar|first1=Sibsankar|last2=Aravind|first2=Alex Alagarsamy|title=Operating Systems|date=2010|publisher=Pearson Education India|isbn=978-8131730225|page=269|url=https://books.google.com/books?id=orZ0CLxEMXEC&pg=PA269|accessdate=October 16, 2017</ref>

The computer's operating system, using a combination of hardware and software, maps memory addresses used by a program, called ''Virtual address space|virtual addresses'', into ''physical addresses'' in computer memory. Main storage#Primary storage|Main storage, as seen by a process or task, appears as a contiguous address space or collection of contiguous Memory segmentation|segments. The operating system manages virtual address spaces and the assignment of real memory to virtual memory. Address translation hardware in the CPU, often referred to as a memory management unit or ''MMU'', automatically translates virtual addresses to physical addresses. Software within the operating system may extend these capabilities to provide a virtual address space that can exceed the capacity of real memory and thus reference more memory than is physically present in the computer.

The primary benefits of virtual memory include freeing applications from having to manage a shared memory space, increased security due to memory isolation, and being able to conceptually use more memory than might be physically available, using the technique of paging.

 Properties 
Virtual memory makes application programming easier by hiding Fragmentation (computer)|fragmentation of physical memory; by delegating to the kernel the burden of managing the Computer data storage#Hierarchy of storage|memory hierarchy (eliminating the need for the program to handle overlay (programming)|overlays explicitly); and, when each process is run in its own dedicated address space, by obviating the need Relocation (computer science)|to relocate program code or to access memory with Addressing mode#PC-relative|relative addressing.

Memory virtualization can be considered a generalization of the concept of virtual memory.

 Usage 
Virtual memory is an integral part of a modern computer architecture; implementations usually require hardware support, typically in the form of a memory management unit built into the central processing unit|CPU. While not necessary, emulators and virtual machines can employ hardware support to increase performance of their virtual memory implementations.<ref>cite web|title = AMD-V™ Nested Paging|url = http://developer.amd.com/wordpress/media/2012/10/NPT-WP-1%201-final-TM.pdf|publisher = AMD|accessdate = 28 April 2015</ref> Consequently, older operating systems, such as those for the mainframe computer|mainframes of the 1960s, and those for personal computers of the early to mid-1980s (e.g., DOS),<ref>cite web |title=Windows Version History |url=http://support.microsoft.com/kb/32905 |date=September 23, 2011 |publisher=Microsoft |accessdate=March 9, 2015</ref> generally have no virtual memory functionality,Dubious|Prevalence of virtual memory operating systems in the 1960s and early 1970s|reason=a lot of paging computers were shipped in the 1960|date=November 2010 though notable exceptions for mainframes of the 1960s include:

* the Atlas Supervisor for the Atlas (computer)|Atlas
* THE multiprogramming system for the Electrologica X8 (software based virtual memory without hardware support)
* Burroughs MCP|MCP for the Burroughs Corporation|Burroughs B5000
* Michigan Terminal System|MTS, TSS/360 and CP/CMS for the IBM System/360 Model 67
* Multics for the GE-600 series|GE 645
* the Time Sharing Operating System for the RCA Spectra 70/46

and the operating system for the Apple Lisa is an example of a personal computer operating system of the 1980s that features virtual memory.

During the 1960s and early 70s, computer memory was very expensive.  The introduction of virtual memory provided an ability for software systems with large memory demands to run on computers with less real memory.  The savings from this provided a strong incentive to switch to virtual memory for all systems.  The additional capability of providing virtual address spaces added another level of security and reliability, thus making virtual memory even more attractive to the market place.

Most modern operating systems that support virtual memory also run each process (computing)|process in its own dedicated address space. Each program thus appears to have sole access to the virtual memory. However, some older operating systems (such as OS/VS1 and OS/VS2 (SVS)|OS/VS2 SVS) and even modern ones (such as IBM i) are single address space operating systems that run all processes in a single address space composed of virtualized memory.

Embedded systems and other special-purpose computer systems that require very fast and/or very consistent response times may opt not to use virtual memory due to decreased Deterministic algorithm|determinism; virtual memory systems trigger unpredictable trap (computing)|traps that may produce unwanted and unpredictable delays in response to input, especially if the trap requires that data be read into main memory from secondary memory.  The hardware to translate virtual addresses to physical addresses typically requires significant chip area to implement, and not all chips used in embedded systems include that hardware, which is another reason some of those systems don't use virtual memory.

History
In the 1940scitation needed|date=November 2017 and 1950s, all larger programs had to contain logic for managing primary and secondary storage, such as Overlay (programming)|overlaying. Virtual memory was therefore introduced not only to extend primary memory, but to make such an extension as easy as possible for programmers to use.<ref name="denning">cite journal|authorlink=Peter J. Denning|last=Denning|first=Peter|title=Before Memory Was Virtual|journal=In the Beginning: Recollections of Software Pioneers|year=1997|url=http://denninginstitute.com/pjd/PUBS/bvm.pdf|format=PDF</ref> To allow for multiprogramming and computer multitasking|multitasking, many early systems divided memory between multiple programs without virtual memory, such as early models of the PDP-10 via Processor register|registers.

The concept of virtual memory was first developed by German physicist Fritz-Rudolf Güntsch at the Technische Universität Berlin in 1956 in his doctoral thesis, ''Logical Design of a Digital Computer with Multiple Asynchronous Rotating Drums and Automatic High Speed Memory Operation''; it described a machine with 6 100-word blocks of primary core memory and an address space of 1,000 100-word blocks, with hardware automatically moving blocks between primary memory and secondary drum memory.<ref>cite journal|first=Elke|last=Jessen|title=Origin of the Virtual Memory Concept|work=IEEE Annals of the History of Computing|volume=26|issue=4|year=2004|pages=71–72</ref><ref name=springer>Cite journal | last1 = Jessen | first1 = E.| title = Die Entwicklung des virtuellen Speichers| doi = 10.1007/s002870050034 | journal = Informatik-Spektrum| publisher   = Springer Berlin / Heidelberg| issn = 0170-6012| volume = 19 | issue = 4 | pages = 216–219 | year = 1996| language = German| pmid =  | pmc = </ref> Paging was first implemented at the University of Manchester as a way to extend the Atlas Computer's working memory by combining its 16,384 words of primary magnetic core memory|core memory with an additional 98,304 words of secondary drum memory.<ref>cite web|url=http://www.ourcomputerheritage.org/ccs-f5x2.pdf|title=Ferranti Atlas 1 & 2 – Systems Architecture|date=November 12, 2009</ref> The first Atlas was commissioned in 1962 but working prototypes of paging had been developed by 1959.<ref name="denning"/>rp|page=2<ref>R. J. Creasy, "[http://pages.cs.wisc.edu/~stjones/proj/vm_reading/ibmrd2505M.pdf The origin of the VM/370 time-sharing system]", ''IBM Journal of Research & Development'', Vol. 25, No. 5 (September 1981), ''p.'' 486</ref><ref>cite web|url=http://www.computer50.org/kgill/atlas/atlas.html|title=The Atlas|archive-url=https://web.archive.org/web/20141006103119/http://www.computer50.org/kgill/atlas/atlas.html|archive-date=October 6, 2014</ref> In 1961, the Burroughs Corporation independently released the first commercial computer with virtual memory, the B5000, with Segmentation (memory)|segmentation rather than paging.<ref>[http://ianjoyner.name/Burroughs.html Ian Joyner on Burroughs B5000]</ref><ref>Cite book|first=Harvey G.|last=Cragon|title=Memory Systems and Pipelined Processors|publisher=Jones and Bartlett Publishers|page=113|year=1996|url=https://books.google.com/?id=q2w3JSFD7l4C|isbn=0-86720-474-5</ref>

Before virtual memory could be implemented in mainstream operating systems, many problems had to be addressed. Dynamic address translation required expensive and difficult-to-build specialized hardware; initial implementations slowed down access to memory slightly.<ref name="denning" /> There were worries that new system-wide algorithms utilizing secondary storage would be less effective than previously used application-specific algorithms. By 1969, the debate over virtual memory for commercial computers was over;<ref name="denning" /> an IBM research team led by David Sayre showed that their virtual memory overlay system consistently worked better than the best manually controlled systems.<ref>Cite journal | last1 = Sayre | first1 = D. | title = Is automatic "folding" of programs efficient enough to displace manual? | doi = 10.1145/363626.363629 | journal = Communications of the ACM | volume = 12 | issue = 12 | pages = 656 | year = 1969 | pmid =  | pmc = </ref> Throughout the 1970s, the IBM 370 series running their virtual-storage based operating systems provided a means for business users to migrate multiple older systems into fewer, more powerful, mainframes that had improved price/performance. The first minicomputer to introduce virtual memory was the Norwegian NORD-1; during the 1970s, other minicomputers implemented virtual memory, notably VAX models running OpenVMS|VMS.

Virtual memory was introduced to the x86 architecture with the protected mode of the Intel 80286 processor, but its segment swapping technique scaled poorly to larger segment sizes. The Intel 80386 introduced paging support underneath the existing Segmentation (memory)|segmentation layer, enabling the page fault exception to chain with other exceptions without double fault. However, loading segment descriptors was an expensive operation, causing operating system designers to rely strictly on paging rather than a combination of paging and segmentation.

Paged virtual memory
Refimprove section|date=December 2010
Nearly all current implementations of virtual memory divide a virtual address space into Page (computer memory)|pages, blocks of contiguous virtual memory addresses. Pages on contemporary<ref group=NB>IBM DOS/360 and successors#DOS/VS|DOS/VS, OS/VS1 and DOS/VS only supported 2&nbsp;KB pages.</ref> systems are usually at least 4 kilobytes in size; systems with large virtual address ranges or amounts of real memory generally use larger page sizes.<ref>cite book|last1=Quintero|first1=Dino, et.al.|title=IBM Power Systems Performance Guide: Implementing and Optimizing|date=May 1, 2013|publisher=IBM Corporation|isbn=0738437662|page=138|url=https://books.google.com/books?id=lHTJAgAAQBAJ&pg=PA138|accessdate=July 18, 2017</ref>

=Page tables=
Page tables are used to translate the virtual addresses seen by the application into physical addresses used by the hardware to process instructions;<ref>cite book|last1=Sharma|first1=Dp|title=Foundation of Operating Systems|date=2009|publisher=Excel Books India|isbn=978-81-7446-626-6|page=62|url=https://books.google.com/books?id=AjWh-o7eICMC&pg=PA62|accessdate=July 18, 2017</ref> such hardware that handles this specific translation is often known as the memory management unit. Each entry in the page table holds a flag indicating whether the corresponding page is in real memory or not.  If it is in real memory, the page table entry will contain the real memory address at which the page is stored.  When a reference is made to a page by the hardware, if the page table entry for the page indicates that it is not currently in real memory, the hardware raises a page fault trap (computing)|exception, invoking the paging supervisor component of the operating system.

Systems can have one page table for the whole system, separate page tables for each application and segment, a tree of page tables for large segments or some combination of these. If there is only one page table, different applications multiprogramming|running at the same time use different parts of a single range of virtual addresses. If there are multiple page or segment tables, there are multiple virtual address spaces and concurrent applications with separate page tables redirect to different real addresses.

Some earlier systems with smaller real memory sizes, such as the SDS 940, used ''Page address register|page registers'' instead of page tables in memory for address translation.

=Paging supervisor=
This part of the operating system creates and manages page tables. If the hardware raises a page fault exception, the paging supervisor accesses secondary storage, returns the page that has the virtual address that resulted in the page fault, updates the page tables to reflect the physical location of the virtual address and tells the translation mechanism to restart the request.

When all physical memory is already in use, the paging supervisor must free a page in primary storage to hold the swapped-in page. The supervisor uses one of a variety of page replacement algorithms such as Page replacement algorithm#Least recently used|least recently used to determine which page to free.

=Pinned pages=
Operating systems have memory areas that are ''pinned'' (never swapped to secondary storage). Other terms used are ''locked'', ''fixed'', or ''wired'' pages.  For example, interrupt mechanisms rely on an array of pointers to their handlers, such as I/O completion and page fault. If the pages containing these pointers or the code that they invoke were pageable, interrupt-handling would become far more complex and time-consuming, particularly in the case of page fault interruptions. Hence, some part of the page table structures is not pageable.

Some pages may be pinned for short periods of time, others may be pinned for long periods of time, and still others may need to be permanently pinned. For example:
* The paging supervisor code and drivers for secondary storage devices on which pages reside must be permanently pinned, as otherwise paging wouldn't even work because the necessary code wouldn't be available.
* Timing-dependent components may be pinned to avoid variable paging delays.
* Data buffers that are accessed directly by peripheral devices that use direct memory access or I/O channels must reside in pinned pages while the I/O operation is in progress because such devices and the Bus (computing)|buses to which they are attached expect to find data buffers located at physical memory addresses; regardless of whether the bus has a IOMMU|memory management unit for I/O, transfers cannot be stopped if a page fault occurs and then restarted when the page fault has been processed.

In IBM's operating systems for System/370 and successor systems, the term is "fixed", and such pages may be long-term fixed, or may be short-term fixed, or may be unfixed (i.e., pageable). System control structures are often long-term fixed (measured in wall-clock time, i.e., time measured in seconds, rather than time measured in fractions of one second) whereas I/O buffers are usually short-term fixed (usually measured in significantly less than wall-clock time, possibly for tens of milliseconds). Indeed, the OS has a special facility for "fast fixing" these short-term fixed data buffers (fixing which is performed without resorting to a time-consuming Supervisor Call instruction).

Multics used the term "wired". OpenVMS and Microsoft Windows|Windows refer to pages temporarily made nonpageable (as for I/O buffers) as "locked", and simply "nonpageable" for those that are never pageable.

Virtual-real operation
In OS/VS1 and similar OSes, some parts of systems memory are managed in "virtual-real" mode, called "V=R". In this mode every virtual address corresponds to the same real address. This mode is used for interrupt mechanisms, for the paging supervisor and page tables in older systems, and for application programs using non-standard I/O management. For example, IBM's z/OS has 3 modes (virtual-virtual, virtual-real and virtual-fixed).<ref name="IBMzOSConcepts">cite web|title=z/OS Basic Skills Information Center: z/OS Concepts |url=http://publib.boulder.ibm.com/infocenter/zoslnctr/v1r7/topic/com.ibm.zconcepts.doc/zconcepts.pdf |format=PDF </ref>Page needed|date=September 2010

=Thrashing=
When paging and Paging#Page stealing|page stealing are used, a problem called "thrashing (computer science)|thrashing" can occur, in which the computer spends an unsuitably large amount of time transferring pages to and from a backing store, hence slowing down useful work. A task's working set is the minimum set of pages that should be in memory in order for it to make useful progress. Thrashing occurs when there is insufficient memory available to store the working sets of all active programs. Adding real memory is the simplest response, but improving application design, scheduling, and memory usage can help. Another solution is to reduce the number of active tasks on the system. This reduces demand on real memory by swapping out the entire working set of one or more processes.

Segmented virtual memory
Some systems, such as the Burroughs Corporation|Burroughs B5500,<ref>cite book|author=Burroughs|id=1021326|title=Burroughs B5500 Information Processing System Reference Manual|url=http://bitsavers.org/pdf/burroughs/B5000_5500_5700/1021326_B5500_RefMan_May67.pdf|year=1964|publisher=Burroughs Corporation|accessdate=November 28, 2013</ref> use segmentation (memory)|segmentation instead of paging, dividing virtual address spaces into variable-length segments. A virtual address here consists of a segment number and an offset within the segment. The Intel 80286 supports a similar segmentation scheme as an option, but it is rarely used. Segmentation and paging can be used together by dividing each segment into pages; systems with this memory structure, such as Multics and IBM System/38, are usually paging-predominant, segmentation providing memory protection.<ref>Cite book|url = http://www.textfiles.com/bitsavers/pdf/ge/GE-645_SystemMan_Jan68.pdf|format = PDF|title = GE-645 System Manual|pages = 21–30|date = January 1968|accessdate = 28 April 2015</ref><ref>cite web|author=Fernando J. Corbató|Corbató, F.J.; and Victor A. Vyssotsky|Vyssotsky, V. A. |title=Introduction and Overview of the Multics System |url=http://www.multicians.org/fjcc1.html |accessdate=2007-11-13 </ref><ref>cite web|author1=Glaser, Edward L. |author2=Couleur, John F. |author3=Oliver, G. A. |last-author-amp=yes |title=System Design of a Computer for Time Sharing Applications |url=http://www.multicians.org/fjcc2.html </ref>

In the Intel 80386 and later IA-32 processors, the segments reside in a 32-bit linear, paged address space. Segments can be moved in and out of that space; pages there can "page" in and out of main memory, providing two levels of virtual memory; few if any operating systems do so, instead using only paging. Early non-hardware-assisted x86 virtualization solutions combined paging and segmentation because x86 paging offers only two protection domains whereas a VMM / guest OS / guest applications stack needs three.<ref>[http://www.hotchips.org/wp-content/uploads/hc_archives/hc17/1_Sun/HC17.T1P2.pdf J. E. Smith, R. Uhlig (August 14, 2005) ''Virtual Machines: Architectures, Implementations and Applications'', HOTCHIPS 17, Tutorial 1, part 2]</ref>rp|22 The difference between paging and segmentation systems is not only about memory division; segmentation is visible to user processes, as part of memory model semantics. Hence, instead of memory that looks like a single large space, it is structured into multiple spaces.

This difference has important consequences; a segment is not a page with variable length or a simple way to lengthen the address space. Segmentation that can provide a single-level memory model in which there is no differentiation between process memory and file system consists of only a list of segments (files) mapped into the process's potential address space.<ref>Cite journal|last=Bensoussan
|first=André|last2=Clingen|first2=CharlesT.|last3=Daley|first3=Robert C.|date=May 1972|title=The Multics Virtual Memory: Concepts and Design|journal=Communications of the ACM|volume=15|issue=5|pages=308–318|url=http://www.multicians.org/multics-vm.html|doi=10.1145/355602.361306</ref>

This is not the same as the mechanisms provided by calls such as mmap and Win32's MapViewOfFile, because inter-file pointers do not work when mapping files into semi-arbitrary places. In Multics, a file (or a segment from a multi-segment file) is mapped into a segment in the address space, so files are always mapped at a segment boundary. A file's linkage section can contain pointers for which an attempt to load the pointer into a register or make an indirect reference through it causes a trap. The unresolved pointer contains an indication of the name of the segment to which the pointer refers and an offset within the segment; the handler for the trap maps the segment into the address space, puts the segment number into the pointer, changes the tag field in the pointer so that it no longer causes a trap, and returns to the code where the trap occurred, re-executing the instruction that caused the trap.<ref>cite web |title=Multics Execution Environment |url=http://www.multicians.org/exec-env.html |website=Multicians.org |access-date=October 9, 2016</ref> This eliminates the need for a Linker (computing)|linker completely<ref name="denning" /> and works when different processes map the same file into different places in their private address spaces.<ref>Cite book|first=Elliott I.|last=Organick|title=The Multics System: An Examination of Its Structure|publisher=MIT Press|year=1972|isbn=0-262-15012-3</ref>

Address space swapping
Some operating systems provide for swapping entire address spaces, in addition to whatever facilities they have for paging and segmentation. When this occurs, the OS writes those pages and segments currently in real memory to swap files. In a swap-in, the OS reads back the data from the swap files but does not automatically read back pages that had been paged out at the time of the swap out operation.

IBM's MVS, from OS/360 and successors#OS/VS2 SVS and MVS|OS/VS2 Release 2 through z/OS, provides for marking an address space as unswappable; doing so does not pin any pages in the address space. This can be done for the duration of a job by entering the name of an eligible<ref>The most important requirement is that the program be APF authorized.</ref> main program in the Program Properties Table with an unswappable flag. In addition, privileged code can temporarily make an address space unswappable using a SYSEVENT Supervisor Call instruction (SVC); certain changes<ref>e.g., requesting use of preferred memory</ref> in the address space properties require that the OS swap it out and then swap it back in, using SYSEVENT TRANSWAP.<ref>cite web |title=Control swapping (DONTSWAP, OKSWAP, TRANSWAP) |series=z/OS MVS Programming: Authorized Assembler Services Reference SET-WTO SA23-1375-00 |url=http://pic.dhe.ibm.com/infocenter/zos/v2r1/index.jsp?topic=%2Fcom.ibm.zos.v2r1.ieaa400%2Fswap.htm |date=1990–2014 |website=IBM Knowledge Center |access-date=October 9, 2016</ref>

See also
wikisource |The Paging Game
* CPU design
* Page (computing)
* Cache algorithms
* Memory allocation
* Memory management (operating systems)
* Protected mode, an x86 architecture|x86 mode that allows for virtual memory.
* CUDA Pinned memory

Further reading
* Hennessy, John L.; and Patterson, David A.; ''Computer Architecture, A Quantitative Approach'' (ISBN|1-55860-724-2)

Notes
Reflist|group=NB

References
* FOLDOC
Reflist|30em

External links
* [http://pages.cs.wisc.edu/~remzi/OSTEP Operating Systems: Three Easy Pieces], by Remzi H. Arpaci-Dusseau and Andrea C. Arpaci-Dusseau. Arpaci-Dusseau Books, 2014. Relevant chapters: [http://pages.cs.wisc.edu/~remzi/OSTEP/vm-intro.pdf Address Spaces] [http://pages.cs.wisc.edu/~remzi/OSTEP/vm-mechanism.pdf Address Translation] [http://pages.cs.wisc.edu/~remzi/OSTEP/vm-segmentation.pdf Segmentation] [http://pages.cs.wisc.edu/~remzi/OSTEP/vm-paging.pdf Introduction to Paging] [http://pages.cs.wisc.edu/~remzi/OSTEP/vm-tlbs.pdf TLBs] [http://pages.cs.wisc.edu/~remzi/OSTEP/vm-smalltables.pdf Advanced Page Tables] [http://pages.cs.wisc.edu/~remzi/OSTEP/vm-beyondphys.pdf Swapping: Mechanisms] [http://pages.cs.wisc.edu/~remzi/OSTEP/vm-beyondphys-policy.pdf Swapping: Policies]
* [http://archive.michigan-terminal-system.org/documentation/documents/timeSharingSupervisorPrograms-1971.pdf "Time-Sharing Supervisor Programs"] by Michael T. Alexander in ''Advanced Topics in Systems Programming'', University of Michigan Engineering Summer Conference 1970 (revised May 1971), compares the scheduling and resource allocation approaches, including virtual memory and paging, used in four mainframe operating systems: CP-67, TSS/360, Michigan Terminal System|MTS, and Multics. 
* [http://linux-mm.org/ LinuxMM: Linux Memory Management].
* [http://gnulinuxclub.org/index.php?option=com_content&task=view&id=161&Itemid=32 Birth of Linux Kernel], mailing list discussion.
* webarchive |url=https://web.archive.org/web/20100622062522/http://msdn2.microsoft.com/en-us/library/ms810616.aspx |date=June 22, 2010 |title=The Virtual-Memory Manager in Windows NT, Randy Kath, Microsoft Developer Network Technology Group, 12 December 1992 

Memory management navbox

Authority control

DEFAULTSORT:Virtual Memory
Category:Virtual memory| 
Category:School of Computer Science, University of Manchester