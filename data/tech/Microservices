{{unreliable sources|date=October 2018}}

'''Microservices''' are a [[software development]] technique—a variant of the [[service-oriented architecture]] (SOA) architectural style that structures an [[application (computing)|application]] as a collection of [[Coupling (computer programming)|loosely coupled]] services. In a microservices architecture, services are [[Service granularity principle|fine-grained]] and the [[protocol (computing)|protocol]]s are lightweight.  The benefit of decomposing an application into different smaller services is that it improves [[Modular programming|modularity]]. This makes the application easier to understand, develop, test, and become more resilient to architecture erosion.<ref name="Micro_Chen">{{cite conference

|url= https://www.researchgate.net/publication/323944215_Microservices_Architecting_for_Continuous_Delivery_and_DevOps
|title= Microservices: Architecting for Continuous Delivery and DevOps
|first= Lianping |last= Chen 
|date= 2018 
|conference= The IEEE International Conference on Software Architecture (ICSA 2018)
|conferenceurl= http://icsa-conferences.org/2018/ 
|publisher= IEEE
}}
</ref> It parallelizes [[software development|development]] by enabling small autonomous teams to develop, [[software deployment|deploy]] and scale their respective services independently.<ref>{{Cite web|url=http://microservices.io/patterns/microservices.html|title=Microservice architecture pattern|last=Richardson|first=Chris|date=|website=microservices.io|archive-url=|archive-date=|dead-url=|access-date=2017-03-19}}</ref> It also allows the architecture of an individual service to emerge through continuous [[refactoring]].<ref name="Ach_Chen">{{cite conference 
|title= Towards an Evidence-Based Understanding of Emergence of Architecture through Continuous Refactoring in Agile Software Development
|first= Lianping |last= Chen 
|first2= Muhammad|last2= Ali Babar|date= 2014 
|conference= The 11th Working IEEE/IFIP Conference on Software Architecture(WICSA 2014)
|conferenceurl= https://web.archive.org/web/20140730053f454/http://wicsa2014.org/ 
|publisher= IEEE
|doi = 10.1109/WICSA.2014.45}}
</ref> Microservices-based architectures enable [[continuous delivery]] and deployment.<ref>{{Cite journal|last=Balalaie|first=Armin|last2=Heydarnoori|first2=Abbas|last3=Jamshidi|first3=Pooyan|date=May 2016|title=Microservices Architecture Enables DevOps: Migration to a Cloud-Native Architecture|journal=IEEE Software|volume=33|issue=3|pages=42–52|doi=10.1109/ms.2016.64|issn=0740-7459|hdl=10044/1/40557}}</ref>

== Introduction ==
Even though there is no official definition of what microservices are, a consensus view has evolved over time, in the industry. Some of the defining characteristics that are frequently cited include:
* Per [[Martin Fowler (software engineer)|Martin Fowler]] and other experts, services in a microservice architecture (MSA) are often [[Process (computing)|processes]] that communicate over a [[Computer network|network]] to fulfill a goal using technology-agnostic [[Communications protocol|protocols]] such as HTTP.<ref name="martinfowler">{{cite web|url=http://martinfowler.com/articles/microservices.html|title=Microservices|author=Martin Fowler|archive-url=https://web.archive.org/web/20180214171522/https://martinfowler.com/articles/microservices.html|archive-date=14 February 2018|dead-url=no}}</ref><ref>{{cite book|title=Building Microservices|last=Newman|first=Sam|publisher=O'Reilly Media|isbn=978-1491950357|date=2015-02-20}}</ref><ref>{{cite book|url=http://microservices-book.com|title=Microservices: Flexible Software Architectures|isbn=978-0134602417|last1=Wolff|first1=Eberhard|date=2016-10-12}}</ref>
* Services in a microservice architecture are independently deployable.<ref name="NMMA16">Nadareishvili, I., Mitra, R., McLarty, M., Amundsen, M., Microservice Architecture: Aligning Principles, Practices, and Culture, O’Reilly 2016</ref><ref name="Micro_Chen"/>
* Services are organized around fine-grained business capabilities. The granularity of the Microservice is important - because this is key to how this approach is different from [[Service-oriented architecture|SOA.]]
* Services can be implemented using different [[programming language]]s, [[database]]s, hardware and software environment, depending on what fits best.<ref name="Micro_Chen"/> This does not mean that a single microservice is written in a patchwork of programming languages. While it is almost certainly the case that different components that the service is composed of, will require different languages or API's (example, the web server layer may be in Java or Javascript, but the database may use SQL to communicate to an RDBMS), this is really reflective of a comparison to the monolithic architecture style. If a monolithic application were to be re-implemented as a set of microservices, then the individual services could pick their own implementing languages. So one microservice could pick Java for the web layer, and another microservice could pick a [[Node.js]] based implementation, but within each microservice component, the implementing language would be uniform.
* Services are small in size, messaging enabled, bounded by contexts, autonomously developed, independently deployable, decentralized and [[Build automation|built]] and [[Application release automation|released with automated processes]].<ref name="NMMA16" />

A Microservice is ''not'' a layer within a monolithic application (example, the web controller, or the backend-for-frontend<ref>{{cite web |title=Backends For Frontends Pattern |url=https://docs.microsoft.com/en-us/azure/architecture/patterns/backends-for-frontends |website=Microsoft Azure Cloud Design Patterns |publisher=Microsoft}}</ref>). Rather it is a self-contained piece of business function with clear interfaces, and may, through its own internal components, implement a layered architecture. From a strategy perspective, microservices architecture essentially follow to the [[Unix philosophy]] of "Do one thing and do it well".<ref>{{cite book|asin= B00VJ3NP4A|title= Microservices: Patterns and Applications|author= Lucas Krause}}</ref> [[Martin Fowler (software engineer)|Martin Fowler]] describes a microservices-based architecture as having the following properties:<ref name="martinfowler"/> 
* Naturally enforces a [[Modular programming|modular]] structure.<ref>[https://www.forbes.com/sites/oracle/2019/01/07/grails-founder-what-java-developers-dont-know-about-memory-can-cost-them-money-in-the-cloud/#3e7ab84a44e1 Grails Founder: What Java Developers Don’t Know About Memory Can Cost Them Money in the Cloud] ''[[Forbes]]'' Retrieve 9 January 2019</ref>
* Lends itself to a [[continuous delivery]] software development process. A change to a small part of the application only requires rebuilding and redeploying only one or a small number of services.<ref>[https://docs.microsoft.com/en-us/azure/architecture/microservices/ci-cd Designing microservices: Continuous integration] ''[[Microsoft]]'' Retrieved 9 January 2018</ref>
* Adheres to principles such as [[Service granularity principle|fine-grained]] [[software interface|interface]]s (to independently deployable services), business-driven development (e.g. [[domain-driven design]]).<ref>Josuttis, N. (2007). SOA in Practice. Sebastopol, CA, USA: O'Reilly. {{ISBN|978-0-596-52955-0}}.</ref>

It is quite common for such an architectural style to be adopted for [[cloud application|cloud-native applications]], and applications using lightweight [[operating-system-level virtualization|container]] deployment. As explained<ref>{{cite web|url=https://martinfowler.com/bliki/MicroservicePrerequisites.html|title=Microservice Prerequisites|author=[[Martin Fowler (software engineer)|Martin Fowler]]}}</ref> by Martin Fowler, because of the large number (when compared to monolithic application implementations) of services, decentralized continuous delivery, and [[DevOps]] with holistic service monitoring are necessary to effectively develop, maintain, and operate such applications. A consequence (and rationale for) of following this approach is that the individual microservices can be individually scaled. In the monolithic approach, an application supporting three functions would have to be scaled in its entirety even if only one of these functions had a resource constraint.<ref>{{cite book |last1=Richardson |first1=Chris |title=Microservice Patterns |date=November 2018 |publisher=Manning Publications |location=Chapter 1, section 1.4.1 Scale cube and microservices |isbn=9781617294549}}</ref> With microservices, only the Microservice supporting the function with resource constraints needs to be scaled out, thus providing resource and cost optimization benefits.

== History ==
A workshop of software architects held near Venice in May 2011 used the term "microservice" to describe what the participants saw as a common architectural style that many of them had been recently exploring {{citation needed|date=November 2018}}. In May 2012, the same group decided on "microservices" as the most appropriate name. James Lewis presented some of those ideas as a [[case study]] in March 2012 at 33rd Degree in Kraków in Microservices - Java, the Unix Way, as did Fred George about the same time. [[Adrian Cockcroft]] at Netflix, describing this approach as "fine grained SOA", pioneered the style at web scale, as did many of the others mentioned in this article - Joe Walnes, Dan North, Evan Bottcher and Graham Tackley.<ref>
{{cite web
|author= James Lewis and Martin Fowler
|title= Microservices
|url= http://martinfowler.com/articles/microservices.html
}}
</ref>

Dr. Peter Rodgers introduced the term "Micro-[[web service|Web-Services]]" during a presentation at the Web Services Edge conference in 2005. On slide #4 of the conference presentation, he states that "[[Software component]]s are Micro-Web-Services".<ref>{{cite web|last1=Rodgers|first1=Peter|title=Service-Oriented Development on NetKernel- Patterns, Processes & Products to Reduce System Complexity Web Services Edge 2005 East: CS-3|url=http://www.cloudcomputingexpo.com/node/80883|website=CloudComputingExpo 2005|publisher=SYS-CON TV|accessdate=3 July 2017}}</ref> Juval Löwy had similar precursor ideas about classes being [[Granularity#Computing|granular]] services, as the next evolution of [[Microsoft]] architecture.<ref>{{cite web|last1=Löwy|first1=Juval|title=Every Class a WCF Service|url=https://channel9.msdn.com/Shows/ARCast.TV/ARCastTV-Every-Class-a-WCF-Service-with-Juval-Lowy|website= Channel9, ARCast.TV|date=October 2007}}</ref><ref>{{cite book  |author= Löwy, Juval  |title= Programming WCF Services 1st Edition |pages= 543–553|date= 2007}}</ref><ref>{{cite web|last1=Löwy|first1=Juval|title=Every Class As a Service|url=https://www.youtube.com/watch?v=w-Hxc6uWCPg|website=Microsoft TechEd Conference, SOA206|archiveurl=https://blogs.msdn.microsoft.com/drnick/2009/04/29/wcf-at-teched-2009/|archive-date= 2010|date=May 2009}}</ref> "Services are composed using [[Pipeline (Unix)|Unix-like pipelines]] (the [[WWW|Web]] meets Unix = true [[Loose coupling|loose-coupling]]). Services can call services (+multiple language run-times). Complex service-assemblies are abstracted behind simple [[URI]] interfaces. Any service, at any granularity, can be exposed." He described how a well-designed service platform "applies the underlying architectural principles of the [[WWW|Web]] and Web services together with Unix-like scheduling and pipelines to provide radical flexibility and improved simplicity by providing a platform to apply service-oriented architecture throughout your application environment".<ref>{{cite web|last1= Rodgers|first1= Peter|title= Service-Oriented Development on NetKernel- Patterns, Processes & Products to Reduce System Complexity|url= http://www.cloudcomputingexpo.com/node/80883|website= CloudComputingExpo|publisher= SYS-CON Media|accessdate= 19 August 2015}}</ref> The design, which originated in a research project at [[Hewlett Packard Labs]], aims to make code less brittle and to make large-scale, complex software systems [[Robustness (computer science)|robust]] to change.<ref>{{cite web|last1= Russell|first1= Perry|last2=Rodgers|first2= Peter|last3= Sellman|first3= Royston|title= Architecture and Design of an XML Application Platform|url= http://www.hpl.hp.com/techreports/2004/HPL-2004-23.html|website= HP Technical Reports|accessdate= 20 August 2015|pages= 62|date= 2004}}</ref> To make "Micro-Web-Services" work, one has to question and analyze the foundations of architectural styles (such as [[Service-oriented architecture|SOA]]) and the role of messaging between software components in order to arrive at a new general computing abstraction.<ref>{{cite journal|last1= Hitchens|first1= Ron|editor1-last= Swaine|editor1-first= Michael|title= Your Object Model Sucks|journal= PragPub Magazine|date= Dec 2014|page= 15}}</ref> In this case, one can think of [[resource-oriented computing]] (ROC) as a generalized form of the Web abstraction. If in the Unix abstraction "[[everything is a file]]", in ROC, everything is a "Micro-Web-Service". It can contain information, code or the results of computations so that a service can be either a consumer or producer in a symmetrical and evolving architecture.

'''Microservices''' is a specialization of an implementation approach for  [[service-oriented architecture]]s (SOA) used to build flexible, independently deployable [[distributed software|software systems]].<ref name="ieeeswi2">{{Cite journal|year=2017|title=Microservices in Practice, Part 1: Reality Check and Service Design|url=http://ieeexplore.ieee.org/document/7819415/|journal=IEEE Software|volume=34|issue=1|pages=91–98|doi=10.1109/MS.2017.24|last1=Pautasso|first1=Cesare}}</ref> The microservices approach is a first realisation of SOA that followed the introduction of [[DevOps]] and is becoming more popular for building [[Continuous deployment|continuously deployed]] systems.<ref>{{cite web|url=https://www.javacodegeeks.com/2014/12/continuous-deployment-strategies.html|title=Continuous Deployment: Strategies|date=|author=|work=javacodegeeks.com|accessdate=28 December 2016}}</ref>

== Service Granularity ==
A key step in defining a Microservice architecture is figuring out how big an individual Microservice has to be. There is no consensus or litmus test for this, as the right answer depends on the business and organizational context. [[Amazon (company)|Amazon]]'s policy is that the team implementing a microservice should be small enough that they can be fed by two-pizzas.<ref name="martinfowler"/> Many organizations choose smaller "squads" - typically 6 to 8 developers. But the key decision hinges around how "clean" the service boundary can be.

On the opposite side of the spectrum, it is considered a bad practice to make the service too small, as then the runtime overhead and the operational complexity can overwhelm the benefits of the approach. When things get too fine-grained, alternative approaches must be considered - such as packaging the function as a library, or by placing the function into other Microservices.{{citation needed|date=January 2019}}

== Linguistic approach ==
A linguistic approach to the development of microservices<ref name="jolie-2">{{cite web|url=http://claudioguidi.blogspot.it/2017/03/what-microservice-from-linguisitc.html|title=What is a microservice? (from a linguistic point of view) |author=Claudio Guidi|date=2017-03-29 }}</ref> focuses on selecting a programming language that can easily represent a microservice as a single software artifact. When effective, the gap between architecting a project and deploying it can be minimized.{{citation needed|date=October 2018}}

One language intended to fill this role is [[Jolie (programming language)|Jolie]].<ref name="jolie-1">{{cite web|url=http://www.jolie-lang.org/vision.html|title=Vision of microservices revolution |author=Jolie Team}}</ref><ref name="jolie-3">{{cite web|url=https://fmontesi.github.io/2015/02/06/programming-microservices-with-jolie.html|title = Programming Microservices with Jolie - Part 1: Data formats, Proxies, and Workflows.|author=Fabrizio Montesi}}</ref>

== Technologies ==

Computer  microservices can be implemented in different programming languages and might use different infrastructures. Therefore the most important technology choices are the way microservices communicate with each other (synchronous, asynchronous, UI integration) and the protocols used for the communication (REST, messaging, ...). In a traditional system most technology choices like the programming language impact the whole systems. Therefore the approach for choosing technologies is quite different.<ref>{{cite book|url=http://practical-microservices.com|title=Microservices - A Practical Guide|isbn=978-1717075901|last1=Wolff|first1=Eberhard}}</ref>

The [[Eclipse Foundation]] has published a specification for developing microservices, Eclipse MicroProfile.<ref>{{cite web|url=https://projects.eclipse.org/projects/technology.microprofile|title=Eclipse MicroProfile|first=Stephanie|last=Swart|date=14 December 2016|website=projects.eclipse.org}}</ref>

== Service Mesh ==

In a service mesh, each service instance is paired with an instance of a reverse proxy server, called a service proxy, sidecar proxy, or sidecar. The service instance and sidecar proxy share a container, and the containers are managed by a container orchestration tool such as [[Kubernetes]].
The service proxies are responsible for communication with other service instances and can support capabilities such as service (instance) discovery, load balancing, authentication and authorization, secure communications, and others.

In a service mesh, the service instances and their sidecar proxy are said to make up the data plane, which includes not only data management but also request processing and response. The service mesh also includes a control plane for managing the interaction between services, mediated by their sidecar proxies. There are several options for service mesh architecture: Istio (a joint project among Google, IBM, and Lyft), Buoyant<ref>{{cite web |title=What's a service mesh? |url=https://blog.buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/ |website=Buoyant |publisher=Buoyant |accessdate=5 December 2018|date=2017-04-25 }}</ref> & others

== Criticism ==
The microservices approach is subject to criticism for a number of issues:
* Services form information barriers<ref name="infoq-1">{{cite web|url=http://www.infoq.com/news/2014/08/failing-microservices|title=Experiences from Failing with Microservices|author=Jan Stenberg|date=11 August 2014}}</ref>
* Inter-service calls over a network have a higher cost in terms of network latency and message processing time than in-process [[function call|calls]] within a [[monolithic system|monolithic]] service process<ref name="martinfowler"/>
* [[Software testing|Testing]] and [[Software deployment|deployment]] are more complicated<ref name="infoqbook"/>
* Moving responsibilities between services is more difficult.<ref name="Micro_Chen"/> It may involve communication between different teams, rewriting the functionality in another language or fitting it into a different infrastructure<ref name="martinfowler"/>
* Viewing the size of services as the primary structuring mechanism can lead to too many services when the alternative of internal modularization may lead to a simpler design.<ref>{{cite web |url=https://www.innoq.com/blog/st/2014/11/how-small-should-your-microservice-be/ |title=How small should your microservice be? |last=Tilkov |first=Stefan |date=17 November 2014 |website=innoq.com |access-date=4 January 2017}}</ref>
* Two-phased commits are regarded as an anti-pattern in microservices based architectures as this results in a tighter coupling of all the participants within the transaction. However, lack of this technology causes awkward dances which have to be implemented by all the transaction participants in order to maintain data consistency<ref>{{cite book |last1=Richardson |first1=Chris |title=Microservice Patterns |date=November 2018 |publisher=Manning Publications |location=Chapter 4. Managing transactions with sagas |isbn=9781617294549}}</ref>
* Development and support of many services is more challenging if they are built with different tools and technologies - this is especially a problem if engineers move between projects frequently

===Cognitive load===
The architecture introduces additional complexity and new problems to deal with, such as [[network latency]], [[message format]]s, [[Load balancing (computing)|load balancing]] and [[fault tolerance]].<ref name="ieeeswmsip2">{{Cite journal|year=2017|title=Microservices in Practice, Part 2: Service Integration and Sustainability|url=http://ieeexplore.ieee.org/document/7888407/|journal=IEEE Software|volume=34|issue=2|pages=97–104|doi=10.1109/MS.2017.56|last1=Pautasso|first1=Cesare}}</ref><ref name="infoqbook">{{cite web|url=http://www.infoq.com/presentations/microservices-pass-spring-cloud-foundry|title=Developing Microservices for PaaS with Spring and Cloud Foundry}}</ref> All of these problems have to be addressed at scale.

The complexity of a [[monolithic application]] doesn't disappear, if it gets re-implemented as a set of microservice applications. Some of the complexity gets translated into operational complexity.<ref>{{cite web|author=[[Martin Fowler (software engineer)|Martin Fowler]]|url=https://www.martinfowler.com/articles/microservice-trade-offs.html#ops|title=Microservice Trade-Offs}}</ref> Other places where the complexity manifests itself is in the increased network traffic and resulting slower performance. Also, an application made up of any number of microservices has a larger number of interface points to access its respective [[software ecosystem|ecosystem]], which increases the architectural complexity.<ref>{{cite news|title=BRASS Building Resource Adaptive Software Systems|agency=DARPA|publisher=U.S. Government|date=April 7, 2015}} "Access to system components and the interfaces between clients and their applications, however, are mediated via a number of often unrelated mechanisms, including informally documented [[application programming interface]]s (APIs), idiosyncratic foreign function interfaces, complex ill-understood model definitions, or ad hoc data formats. These mechanisms usually provide only partial and incomplete understanding of the semantics of the components themselves. In the presence of such complexity, it is not surprising that applications typically bake-in many assumptions about the expected behavior of the ecosystem they interact with."</ref> Various organizing principles (such as [[HATEOAS]], interface and data model documentation captured via [[Swagger (software)|Swagger]], etc) have been applied to reduce the impact of such additional complexity.

== Implementations ==
* Thorntail by [[Red Hat]]
* Helidon by [[Oracle Corporation|Oracle]]
* Meecrowave by [[The Apache Software Foundation|Apache]]

== See also ==
* [[Conway's law]]
* [[Cross-cutting concern]]
* [[DevOps]]
* [[Fallacies of distributed computing]]
* [[gRPC]]
* [[Microkernel]]
* [[Representational state transfer]] (REST)
* [[Service-oriented architecture]] (SOA)
* [[Unix philosophy]]
* [[Self-contained Systems]]
* [[Serverless computing]]
* [[Web-oriented architecture]] (WOA)

== References ==
{{reflist|30em}}

== Further reading ==
* S. Newman, Building Microservices – Designing Fine-Grained Systems, O'Reilly, 2015 {{isbn|978-1491950357}}
* I. Nadareishvili et al., [http://transform.ca.com/rs/117-QWV-692/images/CA%20Technologies%20-%20OReilly%20Microservice%20Architecture%20eBook.pdf Microservices Architecture – Aligning Principles, Practices and Culture], O’Reilly, 2016,   {{isbn|978-1-491-95979-4}}
* SEI SATURN 2015 microservices workshop, https://github.com/michaelkeeling/SATURN2015-Microservices-Workshop 
* Wijesuriya, Viraj Brian (2016-08-29) ''[http://www.slideshare.net/tyrantbrian/microservice-architecture-65505794 Microservice Architecture, Lecture Notes]'' - University of Colombo School of Computing, Sri Lanka

[[Category:Architectural pattern (computer science)]]
[[Category:Service-oriented (business computing)]]